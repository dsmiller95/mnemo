#!/usr/bin/perl
# vim: se expandtab ai tabstop=4 shiftwidth=4:

# mnemo is a memory accellerator.
#
# This implementation is written to use a subset of CGI
# and to store all data as files and directories.

# DATA STRUCTURES
# ===============
# A "page" is a file of "items".
# The page file is a text file whose name ends in ".mnemo".
# Each line of the page file is an "item".
# Item fields are:
#   - uuid (output from uuidgen) [required]
#   - question [required]
#   - answer [required]
#   - interval (seconds)
#   - dueTime (time_t)
# Fields are delimited by the backslash character, '\'.
# Backslashes in the data would have to be HTML coded as "&92;".
# Question and answer are to be in text/HTML format using UTF-8.
# If an item doesn't have an interval, that's set to a default when read.
# If the item doesn't have a dueTime, it is ignored until no other
#   items on the page are due.

$| = 1; # immediately flush all writes

use Encode qw(encode decode);

$minimumSessionDuration = 5 * 60; # prevents user from shutting self out.
$defaultSessionDuration = 15 * 60; # Fifteen minutes.

$minimumInterval = 60;
$defaultInterval = 60;

$opsDir = $ENV{'HOME'} . '/httpi_mnemo/mnemo_ops';

$HOUR = 3600;
$DAY = $HOUR * 24;
$WEEK = $DAY * 7;
$YEAR = $DAY * 365.25;
$MONTH = $YEAR / 12.0;

&main;

exit 1;


sub main() {
    &parseArgs($ENV{'QUERY_STRING'});

    # This lets me throw a debug page just by including a hidden
    # input in a form: <input type="hidden" name="debug" value="1">
    if (defined($parameters{'debug'})) {
        &debugPage('DEBUG');
        return;
    }

    # This generates a report of all users progress.
    if (defined($parameters{'report'})) {
        &reportPage;
        return;
    }

    # If no "user", then they haven't logged in.
    if (length($parameters{'user'}) == 0) {
        &loginPage;
        return;
    }
    # If there's a "password" then they're trying to log in.
    if (length($parameters{'password'}) > 0) {
        &passwordPage;
        return;
    }
    # If there's neither "password" nor "session", they need to log in.
    if (length($parameters{'session'}) == 0) {
        &loginPage;
        return;
    }

    &readSessionFile;

    # If they don't know the current session ID, then kick them back
    # to the login page.  This will not interrupt a legitimate session
    # unless they successfully log in.
    if ($session{'sessionID'} != $parameters{'session'}) {
        &loginPage;
        return;
    }

    &readUserFile;

    # This makes it a little more secure, and lets the user get
    # a sense of accomplishment at the end of their session.
    if ((time - $session{'sessionID'}) > &userSessionDuration) {
        &finishedPage;
        return;
    }

    if ($session{'showPage'} eq 'edit') {
        if ($parameters{'action'} eq 'quit') {
            %item = ();
            $session{'itemUuid'} = '';
            $session{'showPage'} = 'question';
            &writeSessionFile;
            &questionPage;
        } elsif ($parameters{'action'} eq 'save') {
            &saveItem;
            &editPage('(saved)');
        } elsif ($parameters{'action'} eq 'flip') {
            &flipItem;
            &editPage('(flipped item inserted)');
        } elsif ($parameters{'action'} eq 'add') {
            &addItem;
            &editPage('(item added)');
        } elsif ($parameters{'action'} eq 'delete') {
            &deleteItem;
            &editPage('(item deleted)');
        } elsif ($parameters{'action'} eq 'nextItem') {
            &gotoPrevNextItem('next');
            &editPage;
        } elsif ($parameters{'action'} eq 'prevItem') {
            &gotoPrevNextItem('prev');
            &editPage;
        } else {
            &editPage;
        }
    } elsif ($session{'showPage'} eq 'answer') {
        if ($parameters{'action'} eq 'edit') {
            $session{'showPage'} = 'edit';
            &writeSessionFile;
            &editPage
        } elsif ($parameters{'response'} =~ /^[0123]$/) {
            &recordResponse;
            %item = ();
            $session{'itemUuid'} = '';
            $session{'showPage'} = 'question';
            &writeSessionFile;
            &questionPage;
        } else {
            &answerPage;
        }
    } else {
        # assuming ($session{'showPage'} eq 'question')
        if ($parameters{'action'} eq 'edit') {
            $session{'showPage'} = 'edit';
            &writeSessionFile;
            &editPage
        } elsif ($parameters{'action'} eq 'showAnswer') {
            $session{'showPage'} = 'answer';
            &writeSessionFile;
            &answerPage;
        } else {
            &questionPage;
        }
    }
}

sub readPageFile() {
    my ($line, $uuid, $question, $answer, $interval, $dueTime);

    %page = ();
    @pageUuids = (); # (this is for keeping them in order in the file)
    open(PAGE, "<$opsDir/data/$parameters{'user'}/$session{'pagePath'}.mnemo") || return;
    while ($line = <PAGE>) {
        chomp($line);
        if (($uuid, $question, $answer, $interval, $dueTime) =
                split(/\\/, $line)) {
            if (0 == $interval) {
                $interval = $defaultInterval;
            } elsif ($minimumInterval > $interval) {
                $interval = $minimumInterval;
            }
            push(@pageUuids, $uuid);
            $page{$uuid} = {
                'uuid' => $uuid,
                'question' => $question,
                'answer' => $answer,
                'interval' => $interval,
                'dueTime' => $dueTime
            };
        }
    }
    close(PAGE);
}

sub writePageFile() {
    my ($tmp);
    open(PAGE, ">$opsDir/data/$parameters{'user'}/$session{'pagePath'}.mnemo");
    foreach my $uuid (@pageUuids) {
        %tmp = %{$page{$uuid}};
        print PAGE join('\\', $tmp{'uuid'}, $tmp{'question'},
                        $tmp{'answer'}, $tmp{'interval'},
                        $tmp{'dueTime'}), "\n";
    }
    close(PAGE);
}

sub getNextPage() {
    my ($i, $d, $p, $oldPath, @paths);
    my ($getIt) = (0);
    $oldPath = $session{'pagePath'};
    $session{'pagePath'} = '';
    $d = "$opsDir/data/$parameters{'user'}/";
    @paths = `find "$d" -type f -name '*.mnemo' | sort`;
    chomp(@paths);
    for ($i = 0; $i <= $#paths; $i++) {
        $p = substr(substr($paths[$i], length($d)), 0, -6);
        if ($getIt != 0) {
            $session{'pagePath'} = $p;
            last;
        } elsif ($p eq $oldPath) {
            $getIt = 1;
        }
    }
    &writeSessionFile;
    &readPageFile;
}

sub getNextDueItem() {
    my ($fullPagePath) = $opsDir . '/data/' . $parameters{'user'} .
                        '/' . $session{'pagePath'} . '.mnemo';

    # Start from current pagePath.
    # If pagePath is unreadable or doesn't exist then look for
    # the top one, or error out.
    if (!(-r $fullPagePath)) {
        my ($d) = "$opsDir/data/$parameters{'user'}/";
        my ($p) = `find "$d" -type f -name '*.mnemo' | sort`;
        chomp($p);
        if (-r $p) {
            $session{'pagePath'} = substr(substr($p, length($d)), 0, -6);
        } else {
            &errorPage("getNextDueItem: Can't seem to find any data files.");
            exit(1);
        }
    }
    # Load the page and grep for items which have come due.
    # If none have come due, look for next pagePath or finishPage.
    # From due items, populate %item with the one with the longest interval.
    &readPageFile;
    undef(%item);
    my ($t) = time;
    my (@newItems) = ();
    my ($u, $i);
    foreach $u (@pageUuids) {
        $i = $page{$u};
        if (0 == $$i{'dueTime'}) {
            push(@newItems, $i);
        } elsif ($t >= $$i{'dueTime'}) {
            if ( (! defined(%item)) ||
                 ($item{'interval'} < $$i{'interval'}) ) {
                %item = %$i;
            }
        }
    }
    if ( (! defined(%item)) && ($#newItems >= 0) ) {
        %item = %{$newItems[0]};
    }
    # Make sure %session is updated and written.
    if (defined(%item)) {
        $session{'itemUuid'} = $item{'uuid'};
    } else {
        $session{'itemUuid'} = '';
    }
    &writeSessionFile;
}

sub recordResponse() {
    my ($r) = $parameters{'response'};
    my ($factor);
    my (@k);
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("recordResponse: Page='$session{'pagePath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        exit(1);
    }


    if ($r == 3) {
        $factor = 1.5; # (3/2)
        $session{'response_3'}++;
    } elsif ($r == 2) {
        $factor = 1.0;
        $session{'response_2'}++;
    } elsif ($r == 1) {
        $factor = 0.66666666; # (2/3)
        $session{'response_1'}++;
    } else { # ($r == 0)
        $factor = 0.11111111; # (2/3)^2
        $session{'response_0'}++;
    }
    &writeSessionFile;
    # scatter with a little something random
    my ($scatter) = 0.05;
    $factor *= (((2.0 - $scatter) / 2.0) + ($scatter * rand));
    $factor *= $item{'interval'};
    if ($factor < $minimumInterval) {
        $factor = $minimumInterval;
    }
    $factor = int($factor);

    $item{'interval'} = $factor;
    $item{'dueTime'} = time + $factor;
    $page{$item{'uuid'}} = {%item};
    &writePageFile;
}

# If not in edit mode (then assume question/answer mode):
#   - Requiring page and item:
#       - Show the answer to this item.
#       - Record score for this item (redirect to ShowNextm, this page).
#       - Switch to edit mode ((on this item) in this page).
#   - Requiring a page:
#       - If this page has no items then switch to edit mode,
#           add a new item and then edit that item.
#   - If no pages exist, switch to edit mode and redirect to
#       Request "New Page" dialog.
#   - DEFAULT: Show the next item (this page).  If no due items,
#       go to next page or back to the top of the tree.
sub questionPage() {
    my (@k);
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &getNextDueItem;
        @k = keys(%item);
    }
    while ($#k < 0) {
        &getNextPage;
        if (length($session{'pagePath'}) == 0) {
            &finishedPage;
            return;
        }
        &getNextDueItem;
        @k = keys(%item);
    }
    if ($#k < 0) {
        &finishedPage;
        return;
    }

    my ($sessionDuration) = &prettyDuration(time() - $parameters{'session'});
    my ($interval) = &prettyDuration($item{'interval'});
    my ($widthTerm) = &userWidthTerm;
    my ($editButton) = '';
    if (0 != $user{'showEdit'}) {
        $editButton = '<button name="action" value="edit" type="submit">Edit mode</button>';
    }

    print <<"EndOfQuestionPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="get">
<input type="hidden" name="user" value="$parameters{'user'}">
<input type="hidden" name="session" value="$parameters{'session'}">
$session{'pagePath'}
<table border=1 cellpadding=5 $widthTerm>
<tr><td>$item{'question'}</td></tr>
<tr><td><button name="action" value="showAnswer" type="submit">Show answer</button></td></tr>
</table>
Interval for this item: $interval<br />
Session: $sessionDuration<br />
$editButton
</form>
</body>
</html>
EndOfQuestionPage
}

sub userWidthTerm() {
    my ($term) = ('width="100%"');

    if (0 != $user{'width'}) {
        $term = "width=\"$user{'width'}\"";
    }

    return $term;
}

sub prettyDuration() {
    my ($d) = @_;

    if ($d > (2 * $YEAR)) {
        return int($d / $YEAR) . ' years';
    } elsif ($d > (2 * $MONTH)) {
        return int($d / $MONTH) . ' months';
    } elsif ($d > (2 * $WEEK)) {
        return int($d / $WEEK) . ' weeks';
    } elsif ($d > (2 * $DAY)) {
        return int($d / $DAY) . ' days';
    } elsif ($d > (2 * $HOUR)) {
        return int($d / $HOUR) . ' hours';
    } elsif ($d > 120) {
        return int($d / 60) . ' minutes';
    } else {
        return "$d seconds";
    }
}

sub answerPage() {
    my (@k);
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("answerPage: Page='$session{'pagePath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }

    my ($sessionDuration) = &prettyDuration(time() - $parameters{'session'});
    my ($interval) = &prettyDuration($item{'interval'});
    my ($widthTerm) = &userWidthTerm;

    print <<"EndOfAnswerPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="get">
<input type="hidden" name="user" value="$parameters{'user'}">
<input type="hidden" name="session" value="$parameters{'session'}">
$session{'pagePath'}
<table border=1 cellpadding=5 $widthTerm>
<tr><td>$item{'question'}</td></tr>
<tr><td>$item{'answer'}</td></tr>
</table>
<button type="submit" name="response" value="0">Huh?</button>
<button type="submit" name="response" value="1">No</button>
<button type="submit" name="response" value="2">Slow</button>
<button type="submit" name="response" value="3">Yes!</button><br />
Interval for this item: $interval<br />
Session: $sessionDuration<br />
<button name="action" value="edit" type="submit">Edit mode</button>
</form>
</body>
</html>
EndOfAnswerPage
}

# TODO: if in edit mode:
#   - Request "New Page" dialog.
#   - Request "Item Search" dialog. (Implement later?)
#   - Requiring page and item:
#       - Add the reverse of this item.
#       - Save this item.
#       - Delete this item.
#   - Requiring at least a page:
#       - Go to named item.
#       - Go to last item in previous page.
#       - Add a new item and then edit that item.
#       - Move/Rename this page (and remove empty subdirectories).
#       - Delete this page (and remove empty subdirectories).
#   - Go to named page.
#   - DEFAULT: Switch to learn mode, redirect to ShowNext this page.
sub editPage() {
    my ($msg) = @_;
    my (@k);
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("editPage: Page='$session{'pagePath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }

    my ($itemIdx) = &findStringIn($session{'itemUuid'}, @pageUuids) + 1;
    my ($itemCount) = $#pageUuids + 1;

    print <<"EndOfEditPage";

HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="get">
<input type="hidden" name="user" value="$parameters{'user'}">
<input type="hidden" name="session" value="$parameters{'session'}">
<input type="hidden" name="itemUuid" value="$item{'uuid'}">
Page: '$session{'pagePath'}', item #$itemIdx of $itemCount $msg
<table border="1" cellpadding="5">
<tr><th>QID</th><td>$item{'uuid'}</td></tr>
<tr><th>Question</th><td><input type="text" name="question" value="$item{'question'}"></td></tr>
<tr><th>Answer</th><td><input type="text" name="answer" value="$item{'answer'}"></td></tr>
<tr><th>Due Time</th><td><input type="text" name="dueTime" value="$item{'dueTime'}"></td></tr>
<tr><th>Interval</th><td><input type="text" name="interval" value="$item{'interval'}"></td></tr>
</table>
<table border="0" cellpadding="0">
<tr>
<td><button type="submit" name="action" value="save">Save</button></td>
<td><button type="submit" name="action" value="flip">Flip and insert</button></td>
<td><button type="submit" name="action" value="add">Add new item</button></td>
<td><button type="submit" name="action" value="delete">Delete</button><br /></td>
<td><button type="submit" name="action" value="quit">Quit</button></td>
</tr>
</table>
<table border="0" cellpadding="0">
<tr>
<td><button type="submit" name="action" value="prevItem">Previous item</button></td>
<td><button type="submit" name="action" value="nextItem">Next item</button></td>
<td><button type="submit" name="action" value="gotoItem">Go to item #:</button><input type="text" name="itemIdx"></td>
</tr>
</table>
<table border="0" cellpadding="0">
<tr>
<td><button type="submit" name="action" value="prevPage">Previous page</button></td>
<td><button type="submit" name="action" value="nextPage">Next page</button></td>
<td><button type="submit" name="action" value="gotoPage">Go to page:</button><input type="text" name="pagePath"></td>
</tr>
</table>
<table border="0" cellpadding="0">
<tr>
<td><button type="submit" name="action" value="deletePage">Delete this page</button><br /></td>
<td><button type="submit" name="action" value="addPage">Add new page:</button><input type="text" name="addPagePath"></td>
</tr>
</table>
</form>
</body>
</html>
EndOfEditPage
}

sub saveItem() {
    my (@k);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("saveItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("saveItem: Page='$session{'pagePath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }
    $item{'question'} = $parameters{'question'};
    $item{'answer'} = $parameters{'answer'};
    $item{'dueTime'} = 0 + $parameters{'dueTime'};
    $item{'interval'} = 0 + $parameters{'interval'};

    $item{'question'} =~ s/\r?\n/<br \/>/mg; # HTML'ize newlines
    $item{'answer'} =~ s/\r?\n/<br \/>/mg; # HTML'ize newlines

    $item{'question'} =~ s/\\/&92;/g; # HTML'ize backslashes
    $item{'answer'} =~ s/\\/&92;/g; # HTML'ize backslashes

    $page{$session{'itemUuid'}} = {%item};
    &writePageFile;

    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    &writeSessionFile;
    $parameters{'session'} = $session{'sessionID'};
}

sub gotoPrevNextItem() {
    my ($choice) = @_;

    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("gotoPrevNextItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readPageFile;

    my ($idx) = &findStringIn($session{'itemUuid'}, @pageUuids);

    if ($idx < 0) {
        &errorPage("gotoPrevNextItem: idx=$idx Page='$session{'pagePath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }

    if ($choice eq 'prev') {
        if ($idx > 0) {
            $idx--; # previous item
            # else just stay on the first one
        }
    } else {
        if ($idx < $#pageUuids) {
            $idx++; # next item
            # else just stay on the last one
        }
    }

    $session{'itemUuid'} = $pageUuids[$idx];

    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %{$page{$session{'itemUuid'}}};

    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};
$DBG = 1;
}

# Create a new item from swapped question and answer of the current item,
# and insert it immediately after the current item.
sub flipItem() {
    my (@k);
    my (%newItem);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("flipItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("flipItem: Page='$session{'pagePath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }
    $newItem{'uuid'} = &uuidgen;
    $newItem{'question'} = $item{'answer'};
    $newItem{'answer'} = $item{'question'};
    $newItem{'dueTime'} = time;
    $newItem{'interval'} = $defaultInterval;

    my (@newPageUuids) = ();
    while ($#pageUuids >= 0) {
        push(@newPageUuids, shift(@pageUuids));
        if ($newPageUuids[$#newPageUuids] eq $item{'uuid'}) {
            last;
        }
    }
    push(@newPageUuids, $newItem{'uuid'});
    while ($#pageUuids >= 0) {
        push(@newPageUuids, shift(@pageUuids));
    }

    $page{$newItem{'uuid'}} = {%newItem};
    @pageUuids = @newPageUuids;
    &writePageFile;

    $session{'itemUuid'} = $newItem{'uuid'};
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %newItem;
    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};
}

# Delete the current item and point the edit interface at the next
# item if there is one, or the last item if there isn't.
# If there are no items left, add one!
sub deleteItem() {
    my (@k);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("deleteItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("deleteItem: Page='$session{'pagePath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }

    my (@newPageUuids) = ();
    my ($nextItemUuid) = ();
    while ($#pageUuids >= 0) {
        push(@newPageUuids, shift(@pageUuids));
        if ($newPageUuids[$#newPageUuids] eq $item{'uuid'}) {
            last;
        }
    }
    if ($newPageUuids[$#newPageUuids] eq $item{'uuid'}) {
        pop(@newPageUuids);
        if ($#pageUuids >= 0) {
            $nextItemUuid = $pageUuids[0];
        } elsif ($#newPageUuids >= 0) {
            $nextItemUuid = $newPageUuids[$#newPageUuids];
        }
    }
    while ($#pageUuids >= 0) {
        push(@newPageUuids, shift(@pageUuids));
    }

    @pageUuids = @newPageUuids;
    &writePageFile;

    if (length($nextItemUuid) == 0) {
        &addItem;
        return;
    }

    %item = %{$page{$nextItemUuid}};

    $session{'itemUuid'} = $item{'uuid'};
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};
}

# Create a new blank item and append it to the page.
sub addItem() {
    my (%newItem);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("addItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readPageFile;
    $newItem{'uuid'} = &uuidgen;
    $newItem{'question'} = 'Edit this question.';
    $newItem{'answer'} = 'Edit this answer.';
    $newItem{'dueTime'} = 0;
    $newItem{'interval'} = $defaultInterval;

    push(@pageUuids, $newItem{'uuid'});
    $page{$newItem{'uuid'}} = {%newItem};
    &writePageFile;

    $session{'itemUuid'} = $newItem{'uuid'};
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %newItem;
    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};
}

sub isValidPagePath() {
    my ($path) = @_;

    if (length($session{'pagePath'} == 0)) {
        return 0;
    }
    if (! (-r $session{'pagePath'})) {
        return 0; # What about "-w"?
    }

    return 1;
}

sub userSessionDuration() {
    if (0 == $user{'sessionDuration'}) {
        return $defaultSessionDuration;
    } elsif ($minimumSessionDuration > $user{'sessionDuration'}) {
        return $minimumSessionDuration;
    } else {
        return $user{'sessionDuration'};
    }
}

sub readLinesFromFile() {
    my ($path) = @_;

    open(INFILE, "<$path");
    my (@lines) = <INFILE>;
    close(INFILE);
    chomp(@lines);

    return(grep(/(^$)|(^[^\#])/, @lines));
}

sub writeLinesToFile() {
    my ($path, @lines) = @_;

    open(OUTFILE, ">$path");
    print OUTFILE join("\n", @lines) . "\n";
    close(OUTFILE);
}

sub readUserFile() {
    ($user{'password'},
     $user{'sessionDuration'},
     $user{'width'},
     $user{'showEdit'}
    ) = &readLinesFromFile("$opsDir/users/$parameters{'user'}");
}

sub writeUserFile() {
    &writeLinesToFile("$opsDir/users/$parameters{'user'}",
                      '# User file line fields are:',
                      '#     password',
                      '#     sessionDuration (seconds, zero invokes default)',
                      '#     width during quiz mode (pixels)',
                      '#     show edit button (0=="NO")',
                      '#',
                      $user{'password'},
                      $user{'sessionDuration'},
                      $user{'width'},
                      $user{'showEdit'}
                     );
}

sub readSessionFile() {
    %session = ();
    ($session{'sessionID'},
     $session{'pagePath'},
     $session{'itemUuid'},
     $session{'showPage'},
     $session{'response_0'},
     $session{'response_1'},
     $session{'response_2'},
     $session{'response_3'}
    ) = &readLinesFromFile("$opsDir/sessions/$parameters{'user'}");
}

sub writeSessionFile() {
    &writeLinesToFile("$opsDir/sessions/$parameters{'user'}",
                      '# Session file line fields are:',
                      '#     sessionID (session init timestamp)',
                      '#     pagePath',
                      '#     itemUuid',
                      '#     showPage (question, answer, edit)',
                      '#     number of 0 responses',
                      '#     number of 1 responses',
                      '#     number of 2 responses',
                      '#     number of 3 responses',
                      '#',
                      $session{'sessionID'},
                      $session{'pagePath'},
                      $session{'itemUuid'},
                      $session{'showPage'},
                      $session{'response_0'},
                      $session{'response_1'},
                      $session{'response_2'},
                      $session{'response_3'}
                     );
}

sub newSession() {
    $parameters{'session'} = time;
    &reinitSession;
}

sub reinitSession() {
    %session = (
        'sessionID' => $parameters{'session'},
        'pagePath' => '',
        'itemUuid' => '',
        'showPage' => 'question',
        'response_0' => 0,
        'response_1' => 0,
        'response_2' => 0,
        'response_3' => 0
    );
}

sub reportPage() {
    my (@users) = ();

    if ( (length($parameters{'user'}) > 0) &&
         (-d "$opsDir/data/$parameters{'user'}") ) {
        (@users) = ($parameters{'user'});
    }

    if ($#users < 0) {
        my ($dh);
        if (! opendir($dh, "$opsDir/data")) {
            &errorPage("reportPage: Couldn't open data dir.");
            return;
        }
        (@users) = grep(/^[^\.]/, readdir($dh));
        closedir($dh);
    }

    print <<'EndOfReportPage';
HTTP/1.0 200 ok
Content-Type: text/plain

EndOfReportPage
    my ($d, $p, $u, $i, $done, $due, $new, $t, $t_done, $t_due, $t_new);
    $t = time;
    foreach $u (sort(@users)) {
        $parameters{'user'} = $u;
        &readSessionFile;
        print "'$u'" .
              " ($session{'response_0'}," .
              "$session{'response_1'}," .
              "$session{'response_2'}," .
              "$session{'response_3'})" .
              ": ";
        if ($#users == 0) {
            print "\n";
        }

        ($t_done, $t_due, $t_new) = (0, 0, 0);
        $d = "$opsDir/data/$u/";
        foreach $p (`find "$d" -type f -name '*.mnemo' | sort`) {
            chomp($p);
            $p = substr(substr($p, length($d)), 0, -6);
            $session{'pagePath'} = $p;
            if ($#users == 0) {
                print "    '$p': ";
            }
            &readPageFile;
            ($done, $due, $new) = (0, 0, 0);
            foreach $i (values(%page)) {
                if (0 != $$i{'dueTime'}) {
                    if ($$i{'dueTime'} > $t) {
                        $done++;
                        $t_done++;
                    } else {
                        $due++;
                        $t_due++;
                    }
                } else {
                    $new++;
                    $t_new++;
                }
            }
            if ($#users == 0) {
                print "$new new, $due due, $done done.\n";
            }
        }
        if ($#users == 0) {
            print '    TOTALS: ';
        }
        print "$t_new new, $t_due due, $t_done done.\n";
    }
}

sub passwordPage() {
    &readUserFile;

    if ($parameters{'password'} ne $user{'password'}) {
        &debugPage("parampass: '$parameters{'password'}' userpass: '$user{'password'}'");
        return;
    }

    # write a new session file for this user.
    &newSession;
    &writeSessionFile;

    print <<"EndOfPasswordPage";
HTTP/1.1 200 ok
Refresh: 0; url=mnemo?user=$parameters{'user'}&session=$parameters{'session'}
Content-Type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
Logging in... <br />
<a href="mnemo?user=$parameters{'user'}&session=$parameters{'session'}">Click here</a> if your browser doesn't go automatically.
</body>
</html>
EndOfPasswordPage
}

sub loginPage() {
    print <<"EndOfLoginPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="get">
user <input type="text" name="user" value="$parameters{'user'}" /> <br />
password <input type="password" name="password" /> <br />
<input type="submit" value="Log in" />
<button name="report" value="1" type="submit">Generate report</button>
</form>
</body>
</html>
EndOfLoginPage
}

sub finishedPage() {
    my ($total) = (
        $session{'response_0'} +
        $session{'response_1'} +
        $session{'response_2'} +
        $session{'response_3'});
    my (@percents) = (0, 0, 0, 0);
    if ($total != 0) {
        (@percents) = ();
        foreach my $r ( $session{'response_0'},
                        $session{'response_1'},
                        $session{'response_2'},
                        $session{'response_3'} ) {
            push(@percents, int((100.0 * $r) / $total));
        }
    }

    print <<"EndOfFinishedPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<body bgcolor="#ffffff">
This session is finished.
<table border="1" cellpadding="5">
<tr><th>Huh?</th><td align="right">$session{'response_0'}</td><td align="right">$percents[0]%</td></tr>
<tr><th>No</th><td align="right">$session{'response_1'}</td><td align="right">$percents[1]%</td></tr>
<tr><th>Slow</th><td align="right">$session{'response_2'}</td><td align="right">$percents[2]%</td></tr>
<tr><th>Yes!</th><td align="right">$session{'response_3'}</td><td align="right">$percents[3]%</td></tr>
</table>
<p>
<a href="mnemo?user=$parameters{'user'}">Click here to start a new session.</a>
</body>
</html>
EndOfFinishedPage
}

sub errorPage() {
    my ($message) = @_;
    &debugPage('ERROR: ' . $message);
}

sub debugPage() {
    my ($message) = @_;

    print "HTTP/1.0 200 OK\nContent-type: text/plain; charset=utf-8\n\n";

    print "$message\n\n";

    print "parameters:\n";
    foreach my $k (sort(keys(%parameters))) {
        print "    '$k': '$parameters{$k}'\n";
    }

    print "session:\n";
    foreach my $k (sort(keys(%session))) {
        print "    '$k': '$session{$k}'\n";
    }

    print "pageUuids:\n";
    foreach my $k (@pageUuids) {
        print "    '$k'\n";
    }

    print "page:\n";
    foreach my $k (sort(keys(%page))) {
        print "    '$k':\n";
        foreach my $i (sort(keys(%{$page{$k}}))) {
            print "        '$i' => '${$page{$k}}{$i}'\n";
        }
    }

    print "item:\n";
    foreach my $k (sort(keys(%item))) {
        print "    '$k': '$item{$k}'\n";
    }

    my ($pwd) = `pwd`;
    chomp($pwd);

    $arguments = join(',', @ARGV);

    print <<"EndOfDebugPage";

My uid: $<
My gid: $(
My euid: $>
My egid: $)
My arguments: $arguments

PWD: $pwd

HTTPi CGI env-vars:

EndOfDebugPage

    foreach (sort keys %ENV) {
        print "$_=$ENV{$_}\n"
            if (/^QUERY_/ || /^CONTENT_/ || /^REMOTE_/ || /^REQUEST_/ ||
                /^SCRIPT_/ || /^SERVER_/ || /^HTTP_/);
    }
}

# Note that plusses and Unicode are only parsed from parameter values.
sub parseArgs() {
    my ($queryString) = @_;

    my ($parm, $name, $val);

    %parameters = ();

    foreach my $parm (split(/\&/, $queryString)) {
        ($name, $val) = ($parm =~ /^([^=]+)=?(.*)$/);
        $parameters{$name} = &uriDecode($val);
    }
}

sub uriDecode() {
    my ($encoded) = @_;

    $encoded =~ s/\+/ /g; # plus becomes space

    my (@parts) = split(/(\%..)/, $encoded);
    my ($decoded) = '';
    foreach my $part (@parts) {
        if ($part =~ /^\%[0123456789abcdef]{2}$/i) {
            $decoded .= (chr(hex(substr($part, 1))));
        } else {
            $decoded .= $part;
        }
    }

    return decode('UTF-8', $decoded);
}

sub uuidgen() {
    my ($uuid) = `uuidgen`;
    chomp($uuid);
    return($uuid);
}

sub findStringIn() {
    my ($expr, @list) = @_;
    my ($idx) = -1; # this is the not-found value
    my ($pos);

    for ($pos = 0; $pos <= $#list; $pos++) {
        if ($list[$pos] eq $expr) {
            $idx = $pos;
            last;
        }
    }

    return $idx;
}

