#!/usr/bin/perl
# vim: se expandtab ai tabstop=4 shiftwidth=4:

# mnemo is a memory accellerator.
#
# This implementation is written to use a subset of CGI
# and to store all data as files and directories.

# DATA STRUCTURES
# ===============
# A "page" is a file of "items".
# The page file is a text file whose name ends in ".mnemo".
# Each line of the page file is an "item".
# Item fields are:
#   - uuid (output from uuidgen) [required]
#   - question [required]
#   - answer [required]
#   - interval (seconds)
#   - dueTime (time_t)
# Fields are delimited by the ampersand "&" character.
# Ampersands in the question and answer must be html encoded (&amp;).
# Question and answer are to be in UTF-8.
# If an item doesn't have an interval, it's set to a default when read.
# If the item doesn't have a dueTime, it is ignored until no other
#   items on the page are due.

use Encode qw(encode decode);

$minimumSessionDuration = 5 * 60; # prevents user from shutting self out.
$defaultSessionDuration = 15 * 60; # Fifteen minutes.

$minimumInterval = 60;
$defaultInterval = 60;

$opsDir = $ENV{'HOME'} . '/git/httpi_mnemo/mnemo_ops';

&main;

exit 1;


sub main() {
    &parseArgs($ENV{'QUERY_STRING'});

    # This lets me throw a debug page just by including a hidden
    # input in a form: <input type="hidden" name="debug" value="1">
    if (defined($parameters{'debug'})) {
        &debugPage('DEBUG');
        return;
    }

    # This generates a report of all users progress.
    if (defined($parameters{'report'})) {
        &reportPage;
        return;
    }

    # If no "user", then they haven't logged in.
    if (length($parameters{'user'}) == 0) {
        &loginPage;
        return;
    }
    # If there's a "password" then they're trying to log in.
    if (length($parameters{'password'}) > 0) {
        &passwordPage;
        return;
    }
    # If there's neither "password" nor "session", they need to log in.
    if (length($parameters{'session'}) == 0) {
        &loginPage;
        return;
    }

    &readSessionFile;

    # If they don't know the current session ID, then kick them back
    # to the login page.  This will not interrupt a legitimate session
    # unless they successfully log in.
    if ($session{'sessionID'} != $parameters{'session'}) {
        &loginPage;
        return;
    }

    &readUserFile;

    # This makes it a little more secure, and lets the user get
    # a sense of accomplishment at the end of their session.
    if ((time - $session{'sessionID'}) > &userSessionDuration) {
        &finishedPage;
        return;
    }

    if ($session{'showPage'} eq 'edit') {
        &editPage;
    } elsif ($session{'showPage'} eq 'answer') {
        if ($parameters{'response'} =~ /^[0123]$/) {
            &recordResponse;
            %item = ();
            $session{'itemUuid'} = '';
            $session{'showPage'} = 'question';
            &writeSessionFile;
            &questionPage;
        } else {
            &answerPage;
        }
    } else {
        # assuming ($session{'showPage'} eq 'question')
        if ($parameters{'action'} eq 'showAnswer') {
            $session{'showPage'} = 'answer';
            &writeSessionFile;
            &answerPage;
        } else {
            &questionPage;
        }
    }
}

sub readPageFile() {
    my ($line, $uuid, $question, $answer, $interval, $dueTime);

    %page = ();
    @pageUuids = (); # (this is for keeping them in order in the file)
    open(PAGE, "<$opsDir/data/$parameters{'user'}/$session{'pagePath'}.mnemo") || return;
    while ($line = <PAGE>) {
        chomp($line);
        if (($uuid, $question, $answer, $interval, $dueTime) =
                split(/\\/, $line)) {
            if (0 == $interval) {
                $interval = $defaultInterval;
            } elsif ($minimumInterval > $interval) {
                $interval = $minimumInterval;
            }
            push(@pageUuids, $uuid);
            $page{$uuid} = {
                'uuid' => $uuid,
                'question' => $question,
                'answer' => $answer,
                'interval' => $interval,
                'dueTime' => $dueTime
            };
        }
    }
    close(PAGE);
}

sub writePageFile() {
    my ($tmp);
    open(PAGE, ">$opsDir/data/$parameters{'user'}/$session{'pagePath'}.mnemo");
    foreach my $uuid (@pageUuids) {
        %tmp = %{$page{$uuid}};
        print PAGE join('\\', $tmp{'uuid'}, $tmp{'question'},
                        $tmp{'answer'}, $tmp{'interval'},
                        $tmp{'dueTime'}), "\n";
    }
    close(PAGE);
}

sub getNextPage() {
    my ($i, $d, $p, $oldPath, @paths);
    my ($getIt) = (0);
    $oldPath = $session{'pagePath'};
    $session{'pagePath'} = '';
    $d = "$opsDir/data/$parameters{'user'}/";
    @paths = `find "$d" -type f -name '*.mnemo' | sort`;
    chomp(@paths);
    for ($i = 0; $i <= $#paths; $i++) {
        $p = substr(substr($paths[$i], length($d)), 0, -6);
        if ($getIt != 0) {
            $session{'pagePath'} = $p;
            last;
        } elsif ($p eq $oldPath) {
            $getIt = 1;
        }
    }
    &writeSessionFile;
    &readPageFile;
}

sub getNextDueItem() {
    my ($fullPagePath) = $opsDir . '/data/' . $parameters{'user'} .
                        '/' . $session{'pagePath'} . '.mnemo';

    # Start from current pagePath.
    # If pagePath is unreadable or doesn't exist then look for
    # the top one, or error out.
    if (!(-r $fullPagePath)) {
        my ($d) = "$opsDir/data/$parameters{'user'}/";
        my ($p) = `find "$d" -type f -name '*.mnemo' | sort`;
        chomp($p);
        if (-r $p) {
            $session{'pagePath'} = substr(substr($p, length($d)), 0, -6);
        } else {
            &errorPage("Can't seem to find any data files.");
            exit(1);
        }
    }
    # Load the page and grep for items which have come due.
    # If none have come due, look for next pagePath or finishPage.
    # From due items, populate %item with the one with the shortest interval.
    &readPageFile;
    undef(%item);
    my ($t) = time;
    my (@newItems) = ();
    my ($u, $i);
    foreach $u (@pageUuids) {
        $i = $page{$u};
        if (0 == $$i{'dueTime'}) {
            push(@newItems, $i);
        } elsif ($t >= $$i{'dueTime'}) {
            if ( (! defined(%item)) ||
                 ($item{'interval'} > $$i{'interval'}) ) {
                %item = %$i;
            }
        }
    }
    if ( (! defined(%item)) && ($#newItems >= 0) ) {
        %item = %{$newItems[0]};
    }
    # Make sure %session is updated and written.
    if (defined(%item)) {
        $session{'itemUuid'} = $item{'uuid'};
    } else {
        $session{'itemUuid'} = '';
    }
    &writeSessionFile;
}

sub recordResponse() {
    my ($r) = $parameters{'response'};
    my ($factor);
    my (@k);
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("Page='$session{'pagePath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        exit(1);
    }


    if ($r == 3) {
        $factor = 1.5; # (3/2)
    } elsif ($r == 2) {
        $factor = 1.0;
    } elsif ($r == 1) {
        $factor = 0.66666666; # (2/3)
    } else { # ($r == 0)
        $factor = 0.11111111; # (2/3)^2
    }
    # scatter with a little something random
    my ($scatter) = 0.05;
    $factor *= (((2.0 - $scatter) / 2.0) + ($scatter * rand));
    $factor *= $item{'interval'};
    if ($factor < $minimumInterval) {
        $factor = $minimumInterval;
    }
    $factor = int($factor);

    $item{'interval'} = $factor;
    $item{'dueTime'} = time + $factor;
    $page{$item{'uuid'}} = {%item};
    &writePageFile;
}

# If not in edit mode (then assume question/answer mode):
#   - Requiring page and item:
#       - Show the answer to this item.
#       - Record score for this item (redirect to ShowNextm, this page).
#       - Switch to edit mode ((on this item) in this page).
#   - Requiring a page:
#       - If this page has no items then switch to edit mode,
#           add a new item and then edit that item.
#   - If no pages exist, switch to edit mode and redirect to
#       Request "New Page" dialog.
#   - DEFAULT: Show the next item (this page).  If no due items,
#       go to next page or back to the top of the tree.
sub questionPage() {
    my (@k);
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &getNextDueItem;
        @k = keys(%item);
    }
    while ($#k < 0) {
        &getNextPage;
        if (length($session{'pagePath'}) == 0) {
            &finishedPage;
            return;
        }
        &getNextDueItem;
        @k = keys(%item);
    }
    if ($#k < 0) {
        &finishedPage;
        return;
    }

    print <<"EndOfQuestionPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="get">
<input type="hidden" name="user" value="$parameters{'user'}">
<input type="hidden" name="session" value="$parameters{'session'}">
$session{'pagePath'}
<table border=1 cellpadding=5 width="250">
<tr><td>$item{'question'}</td></tr>
<tr><td align=center><button name="action" value="showAnswer" type="submit">Show answer</button></td></tr>
</table>
</form>
</body>
</html>
EndOfQuestionPage
}

sub answerPage() {
    my (@k);
    &readPageFile;
    %item = %{$page{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("Page='$session{'pagePath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }

    print <<"EndOfAnswerPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="get">
<input type="hidden" name="user" value="$parameters{'user'}">
<input type="hidden" name="session" value="$parameters{'session'}">
$session{'pagePath'}
<table border=1 cellpadding=5 width="250">
<tr><td>$item{'question'}</td></tr>
<tr><td>$item{'answer'}</td></tr>
</table>
<button type="submit" name="response" value="0">Huh?</button>
<button type="submit" name="response" value="1">No</button>
<button type="submit" name="response" value="2">Slow</button>
<button type="submit" name="response" value="3">Yes!</button>
</form>
</body>
</html>
EndOfAnswerPage
}

# If in edit mode:
#   - Request "New Page" dialog.
#   - Request "Item Search" dialog. (Implement later?)
#   - Requiring page and item:
#       - Add the reverse of this item.
#       - Change this item.
#       - Delete this item.
#   - Requiring at least a page:
#       - Go to named item.
#       - Go to last item in previous page.
#       - Add a new item and then edit that item.
#       - Move/Rename this page (and remove empty subdirectories).
#       - Delete this page (and remove empty subdirectories).
#   - Go to named page.
#   - DEFAULT: Switch to learn mode, redirect to ShowNext this page.
sub editPage() {
    print <<"EndOfEditPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="get">
<input type="hidden" name="user" value="$parameters{'user'}">
<input type="hidden" name="session" value="$parameters{'session'}">
<table border=1 cellpadding=5>
<tr><th>Question</th><td><input type="text" name="question" value="$item{'question'}" length="40"></td></tr>
<tr><th>Answer</th><td><input type="text" name="answer" value="$item{'answer'}" length="40"></td></tr>
<tr><th>Due Time</th><td><input type="text" name="dueTime" value="$item{'dueTime'}"></td></tr>
<tr><th>Interval</th><td><input type="text" name="interval" value="$item{'interval'}"></td></tr>
</table>
<button type="submit" name="action" value="save">Save</button>
<button type="reset">Reset</button>
<br />
</form>
</body>
</html>
EndOfEditPage
}

sub isValidPagePath() {
    my ($path) = @_;

    if (length($session{'pagePath'} == 0)) {
        return 0;
    }
    if (! (-r $session{'pagePath'})) {
        return 0; # What about "-w"?
    }

    return 1;
}

sub userSessionDuration() {
    if (0 == $user{'sessionDuration'}) {
        return $defaultSessionDuration;
    } elsif ($minimumSessionDuration > $user{'sessionDuration'}) {
        return $minimumSessionDuration;
    } else {
        return $user{'sessionDuration'};
    }
}

sub readLinesFromFile() {
    my ($path) = @_;

    open(INFILE, "<$path");
    my (@lines) = <INFILE>;
    close(INFILE);
    chomp(@lines);

    return(grep(/(^$)|(^[^\#])/, @lines));
}

sub writeLinesToFile() {
    my ($path, @lines) = @_;

    open(OUTFILE, ">$path");
    print OUTFILE join("\n", @lines) . "\n";
    close(OUTFILE);
}

sub readUserFile() {
    ($user{'password'},
     $user{'sessionDuration'}
    ) = &readLinesFromFile("$opsDir/users/$parameters{'user'}");
}

sub writeUserFile() {
    &writeLinesToFile("$opsDir/users/$parameters{'user'}",
                      '# User file line fields are:',
                      '#     password',
                      '#     sessionDuration (seconds, zero invokes default)',
                      '#',
                      $user{'password'},
                      $user{'sessionDuration'}
                     );
}

sub readSessionFile() {
    %session = ();
    ($session{'sessionID'},
     $session{'pagePath'},
     $session{'itemUuid'},
     $session{'showPage'}
    ) = &readLinesFromFile("$opsDir/sessions/$parameters{'user'}");
}

sub writeSessionFile() {
    &writeLinesToFile("$opsDir/sessions/$parameters{'user'}",
                      '# Session file line fields are:',
                      '#     sessionID (session init timestamp)',
                      '#     pagePath',
                      '#     itemUuid',
                      '#     showPage (question, answer, edit)',
                      '#',
                      $session{'sessionID'},
                      $session{'pagePath'},
                      $session{'itemUuid'},
                      $session{'showPage'}
                     );
}

sub newSession() {
    $parameters{'session'} = time;
    &reinitSession;
}

sub reinitSession() {
    %session = (
        'sessionID' => $parameters{'session'},
        'pagePath' => '',
        'itemUuid' => '',
        'showPage' => 'question'
    );
}

sub reportPage() {
    my ($dh);
    if (! opendir($dh, "$opsDir/data")) {
        &errorPage("Couldn't open data dir.");
        return;
    }
    my (@users) = grep(/^[^\.]/, readdir($dh));
    closedir($dh);

    print <<'EndOfReportPage';
HTTP/1.0 200 ok
Content-Type: text/plain

EndOfReportPage
    my ($d, $p, $u, $i, $done, $due, $new, $t, $t_done, $t_due, $t_new);
    $t = time;
    foreach $u (sort(@users)) {
        $parameters{'user'} = $u;
        print "'$u':\n";

        ($t_done, $t_due, $t_new) = (0, 0, 0);
        $d = "$opsDir/data/$u/";
        foreach $p (`find "$d" -type f -name '*.mnemo' | sort`) {
            chomp($p);
            $p = substr(substr($p, length($d)), 0, -6);
            $session{'pagePath'} = $p;
            print "    '$p': ";
            &readPageFile;
            ($done, $due, $new) = (0, 0, 0);
            foreach $i (values(%page)) {
                if (0 != $$i{'dueTime'}) {
                    if ($$i{'dueTime'} > $t) {
                        $done++;
                        $t_done++;
                    } else {
                        $due++;
                        $t_due++;
                    }
                } else {
                    $new++;
                    $t_new++;
                }
            }
            print "$new new, $due due, $done done.\n";
        }
        print "    TOTALS: $t_new new, $t_due due, $t_done done.\n";
    }
}

sub passwordPage() {
    &readUserFile;

    if ($parameters{'password'} ne $user{'password'}) {
        &debugPage("parampass: '$parameters{'password'}' userpass: '$user{'password'}'");
        return;
    }

    # write a new session file for this user.
    &newSession;
    &writeSessionFile;

    print <<"EndOfPasswordPage";
HTTP/1.1 200 ok
Refresh: 0; url=mnemo?user=$parameters{'user'}&session=$parameters{'session'}
Content-Type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
Logging in... <br />
<a href="mnemo?user=$parameters{'user'}&session=$parameters{'session'}">Click here</a> if your browser doesn't go automatically.
</body>
</html>
EndOfPasswordPage
}

sub loginPage() {
    print <<"EndOfLoginPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="get">
user <input type="text" name="user" value="$parameters{'user'}" /> <br />
password <input type="password" name="password" /> <br />
<input type="submit" />
</form>
<a href="mnemo?report">(Click here for a report of all users' progress.)</a>
</body>
</html>
EndOfLoginPage
}

sub finishedPage() {
    print <<'EndOfFinishedPage';
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<body bgcolor="#ffffff">
This session is finished.
<p>
<a href="mnemo">Click here to start a new session.</a>
</body>
</html>
EndOfFinishedPage
}

sub errorPage() {
    my ($message) = @_;
    &debugPage('ERROR: ' . $message);
}

sub debugPage() {
    my ($message) = @_;

    print "HTTP/1.0 200 OK\nContent-type: text/plain; charset=utf-8\n\n";

    print "$message\n\n";

    print "parameters:\n";
    foreach my $k (sort(keys(%parameters))) {
        print "    '$k': '$parameters{$k}'\n";
    }

    print "session:\n";
    foreach my $k (sort(keys(%session))) {
        print "    '$k': '$session{$k}'\n";
    }

    print "page:\n";
    foreach my $k (sort(keys(%page))) {
        print "    '$k':\n";
        foreach my $i (sort(keys(%{$page{$k}}))) {
            print "        '$i' => '${$page{$k}}{$i}'\n";
        }
    }

    print "item:\n";
    foreach my $k (sort(keys(%item))) {
        print "    '$k': '$item{$k}'\n";
    }

    my ($pwd) = `pwd`;
    chomp($pwd);

    $arguments = join(',', @ARGV);

    print <<"EndOfDebugPage";

My uid: $<
My gid: $(
My euid: $>
My egid: $)
My arguments: $arguments

PWD: $pwd

HTTPi CGI env-vars:

EndOfDebugPage

    foreach (sort keys %ENV) {
        print "$_=$ENV{$_}\n"
            if (/^QUERY_/ || /^CONTENT_/ || /^REMOTE_/ || /^REQUEST_/ ||
                /^SCRIPT_/ || /^SERVER_/ || /^HTTP_/);
    }
}

# Note that plusses and Unicode are only parsed from parameter values.
sub parseArgs() {
    my ($queryString) = @_;

    my ($parm, $name, $val);

    %parameters = ();

    foreach my $parm (split(/\&/, $queryString)) {
        ($name, $val) = ($parm =~ /^([^=]+)=?(.*)$/);
        $parameters{$name} = &uriDecode($val);
    }
}

sub uriDecode() {
    my ($encoded) = @_;

    $encoded =~ s/\+/ /g; # plus becomes space

    my (@parts) = split(/(\%..)/, $encoded);
    my ($decoded) = '';
    foreach my $part (@parts) {
        if ($part =~ /^\%[0123456789abcdef]{2}$/i) {
            $decoded .= (chr(hex(substr($part, 1))));
        } else {
            $decoded .= $part;
        }
    }

    return decode('UTF-8', $decoded);
}

sub uuidgen() {
    my ($uuid) = `uuidgen`;
    chomp($uuid);
    return($uuid);
}

