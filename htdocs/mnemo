#!/usr/bin/perl
# vim: se expandtab ai tabstop=4 shiftwidth=4:

# mnemo is a memory accellerator.
#
# This implementation is written to use a subset of CGI
# and to store all data as files and directories.

# DATA STRUCTURES
# ===============
# A "group" is a file of "items".
# The group file is a text file whose name ends in ".mnemo".
# Each line of the group file is an "item".
# Item fields are:
#   - uuid (output from uuidgen) [required]
#   - question [required]
#   - answer [required]
#   - interval (seconds)
#   - dueTime (time_t)
# Fields are delimited by the backslash character, '\'.
# Backslashes in the data would have to be HTML coded as "&92;".
# Question and answer are to be in text/HTML format using UTF-8.
# If an item doesn't have an interval, that's set to a default when read.
# If the item doesn't have a dueTime, it is ignored until no other
#   items in the group are due.

use Encode qw(encode decode);

$minimumSessionDuration = 5 * 60; # prevents user from shutting self out.
$defaultSessionDuration = 15 * 60; # Fifteen minutes.

$minimumInterval = 60;
$defaultInterval = 60;

$maxGroupPathFieldLength = 60;

$qnaFieldRows = 4;
$qnaFieldCols = 80;

$opsDir = $ENV{'HOME'} . '/httpi_mnemo/mnemo_ops';

$HOUR = 3600;
$DAY = $HOUR * 24;
$WEEK = $DAY * 7;
$YEAR = $DAY * 365.25;
$MONTH = $YEAR / 12.0;

@dayOfWeek = ('Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat');

&main;

exit 1;


sub main() {
    &parseCgiParameters;

    # This lets me throw a debug page just by including a hidden
    # input in a form: <input type="hidden" name="debug" value="1">
    if (defined($parameters{'debug'})) {
        &debugPage('DEBUG');
        return;
    }

    # This generates a report of all users progress.
    if (defined($parameters{'report'})) {
        &reportPage;
        return;
    }

    # If no "user", then they haven't logged in.
    if (length($parameters{'user'}) == 0) {
        &loginPage;
        return;
    }
    # If there's a "password" then they're trying to log in.
    if (length($parameters{'password'}) > 0) {
        &passwordPage;
        return;
    }
    # If there's neither "password" nor "session", they need to log in.
    if (length($parameters{'session'}) == 0) {
        &loginPage;
        return;
    }

    &readSessionFile;

    # If they don't know the current session ID, then kick them back
    # to the login page.  This will not interrupt a legitimate session
    # unless they successfully log in.
    if ($session{'sessionID'} != $parameters{'session'}) {
        &loginPage;
        return;
    }

    &readUserFile;

    # This makes it a little more secure, and lets the user get
    # a sense of accomplishment at the end of their session.
    if ((time - $session{'sessionID'}) > &userSessionDuration) {
        &finishedPage;
        return;
    }

    if ($session{'showPage'} eq 'edit') {
        if ($parameters{'action'} eq 'quit') {
            %item = ();
            $session{'itemUuid'} = '';
            $session{'showPage'} = 'question';
            &writeSessionFile;
            &questionPage;
        } elsif ($parameters{'action'} eq 'save') {
            &saveItem;
            &editPage('(saved)');
        } elsif ($parameters{'action'} eq 'flip') {
            &flipItem;
        } elsif ($parameters{'action'} eq 'duplicate') {
            &duplicateItem;
        } elsif ($parameters{'action'} eq 'add') {
            &addItem;
            &editPage('(item added)');
        } elsif ($parameters{'action'} eq 'delete') {
            &deleteItem;
            &editPage('(item deleted)');
        } elsif ($parameters{'action'} eq 'nextItem') {
            &gotoPrevNextItem('next');
            &editPage;
        } elsif ($parameters{'action'} eq 'prevItem') {
            &gotoPrevNextItem('prev');
            &editPage;
        } elsif ($parameters{'action'} eq 'nextGroup') {
            &gotoPrevNextGroup('next');
            &editPage;
        } elsif ($parameters{'action'} eq 'prevGroup') {
            &gotoPrevNextGroup('prev');
            &editPage;
        } elsif ($parameters{'action'} eq 'deleteGroup') {
            &deleteGroup;
            # (editPage is called from inside deleteGroup)
        } elsif ($parameters{'action'} eq 'addGroup') {
            &addGroup;
            # (editPage is called from inside addGroup)
        } elsif ($parameters{'action'} eq 'moveGroup') {
            &moveGroup;
            # (editPage is called from inside moveGroup)
        } elsif ($parameters{'action'} eq 'downloadGroup') {
            &downloadGroups($session{'groupPath'});
        } elsif ($parameters{'action'} eq 'downloadAll') {
            &downloadGroups(&getAllGroupPaths);
        } elsif ($parameters{'action'} eq 'setIntervalMinute') {
            &setInterval(60);
        } elsif ($parameters{'action'} eq 'setIntervalHour') {
            &setInterval(3600);
        } elsif ($parameters{'action'} eq 'setIntervalDay') {
            &setInterval(86400);
        } elsif ($parameters{'action'} eq 'makeNew') {
            &makeNew;
        } elsif ($parameters{'action'} eq 'makeDueNow') {
            &makeDueNow
        } else {
            &editPage;
        }
    } elsif ($session{'showPage'} eq 'answer') {
        if ($parameters{'action'} eq 'edit') {
            $session{'showPage'} = 'edit';
            &writeSessionFile;
            &editPage
        } elsif ($parameters{'response'} =~ /^[0123]$/) {
            &recordResponse;
            %item = ();
            $session{'itemUuid'} = '';
            $session{'showPage'} = 'question';
            &writeSessionFile;
            &questionPage;
        } else {
            &answerPage;
        }
    } else {
        # assuming ($session{'showPage'} eq 'question')
        if ($parameters{'action'} eq 'edit') {
            $session{'showPage'} = 'edit';
            &writeSessionFile;
            &editPage
        } elsif ($parameters{'action'} eq 'showAnswer') {
            $session{'showPage'} = 'answer';
            &writeSessionFile;
            &answerPage;
        } else {
            &questionPage;
        }
    }
}

sub readGroupFile() {
    my ($line, $uuid, $question, $answer, $interval, $dueTime);

    %group = ();
    @groupUuids = (); # (this is for keeping them in order in the file)
    foreach $line (&readLinesFromFile("$opsDir/data/$parameters{'user'}/$session{'groupPath'}.mnemo")) {
        chomp($line);
        if (($uuid, $question, $answer, $interval, $dueTime) =
                split(/\\/, $line)) {
            if (0 == $interval) {
                $interval = $defaultInterval;
            } elsif ($minimumInterval > $interval) {
                $interval = $minimumInterval;
            }
            push(@groupUuids, $uuid);
            $group{$uuid} = {
                'uuid' => $uuid,
                'question' => $question,
                'answer' => $answer,
                'interval' => $interval,
                'dueTime' => $dueTime
            };
        }
    }
}

sub writeGroupFile() {
    my ($tmp);
    open(GROUP, ">$opsDir/data/$parameters{'user'}/$session{'groupPath'}.mnemo");
    print GROUP "# $session{'groupPath'}\n";
    foreach my $uuid (@groupUuids) {
        %tmp = %{$group{$uuid}};
        print GROUP join('\\', $tmp{'uuid'}, $tmp{'question'},
                        $tmp{'answer'}, $tmp{'interval'},
                        $tmp{'dueTime'}), "\n";
    }
    close(GROUP);
}

sub getAllGroupPaths() {
    my ($d) = "$opsDir/data/$parameters{'user'}/";
    my (@paths) = `find "$d" -type f -name '*.mnemo'`;
    chomp(@paths);
    my ($p);
    foreach $p (@paths) {
        $p = substr(substr($p, length($d)), 0, -6);
    }
    return sort(@paths);
}

sub getNextGroup() {
    my ($i, $d, $p, $oldPath, @paths);
    my ($getIt) = (0);
    $oldPath = $session{'groupPath'};
    $session{'groupPath'} = '';
    $d = "$opsDir/data/$parameters{'user'}/";
    @paths = `find "$d" -type f -name '*.mnemo' | sort`;
    chomp(@paths);
    for ($i = 0; $i <= $#paths; $i++) {
        $p = substr(substr($paths[$i], length($d)), 0, -6);
        if ($getIt != 0) {
            $session{'groupPath'} = $p;
            last;
        } elsif ($p eq $oldPath) {
            $getIt = 1;
        }
    }
    &writeSessionFile;
    &readGroupFile;
}

sub getNextDueItem() {
    my ($fullGroupPath) = $opsDir . '/data/' . $parameters{'user'} .
                        '/' . $session{'groupPath'} . '.mnemo';

    # Start from current groupPath.
    # If groupPath is unreadable or doesn't exist then look for
    # the top one, or error out.
    if (!(-r $fullGroupPath)) {
        my ($d) = "$opsDir/data/$parameters{'user'}/";
        my ($p) = `find "$d" -type f -name '*.mnemo' | sort`;
        chomp($p);
        if (-r $p) {
            $session{'groupPath'} = substr(substr($p, length($d)), 0, -6);
        } else {
            &errorPage("getNextDueItem: Can't seem to find any data files.");
            exit(1);
        }
    }
    # Load the group and grep for items which have come due.
    # If none have come due, look for next groupPath or finishPage.
    # From due items, populate %item with the one with the longest interval.
    &readGroupFile;
    undef(%item);
    my ($t) = time;
    my (@newItems) = ();
    my ($u, $i);
    foreach $u (@groupUuids) {
        $i = $group{$u};
        if (0 == $$i{'dueTime'}) {
            push(@newItems, $i);
        } elsif ($t >= $$i{'dueTime'}) {
            if ( (! defined(%item)) ||
                 ($item{'interval'} < $$i{'interval'}) ) {
                %item = %$i;
            }
        }
    }
    if ( (! defined(%item)) && ($#newItems >= 0) ) {
        %item = %{$newItems[0]};
    }
    # Make sure %session is updated and written.
    if (defined(%item)) {
        $session{'itemUuid'} = $item{'uuid'};
    } else {
        $session{'itemUuid'} = '';
    }
    &writeSessionFile;
}

sub recordResponse() {
    my ($r) = $parameters{'response'};
    my ($factor);
    my (@k);
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("recordResponse: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        exit(1);
    }


    if ($r == 3) {
        $factor = 1.5; # (3/2)
        $session{'response_3'}++;
    } elsif ($r == 2) {
        $factor = 1.0;
        $session{'response_2'}++;
    } elsif ($r == 1) {
        $factor = 0.66666666; # (2/3)
        $session{'response_1'}++;
    } else { # ($r == 0)
        $factor = 0.11111111; # (2/3)^2
        $session{'response_0'}++;
    }
    &writeSessionFile;
    # scatter with a little something random
    my ($scatter) = 0.05;
    $factor *= (((2.0 - $scatter) / 2.0) + ($scatter * rand));
    $factor *= $item{'interval'};
    if ($factor < $minimumInterval) {
        $factor = $minimumInterval;
    }
    $factor = int($factor);

    $item{'interval'} = $factor;
    $item{'dueTime'} = time + $factor;
    $group{$item{'uuid'}} = {%item};
    &writeGroupFile;
}

sub questionPage() {
    my (@k);
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &getNextDueItem;
        @k = keys(%item);
    }
    while ($#k < 0) {
        &getNextGroup;
        if (length($session{'groupPath'}) == 0) {
            &finishedPage;
            return;
        }
        &getNextDueItem;
        @k = keys(%item);
    }
    if ($#k < 0) {
        &finishedPage;
        return;
    }

    my ($sessionDuration) = &prettyInterval(time() - $parameters{'session'});
    my ($interval) = &prettyInterval($item{'interval'});
    my ($widthTerm) = &userWidthTerm;
    my ($editButton) = '';
    if (0 != $user{'showEdit'}) {
        $editButton = '<button name="action" value="edit" type="submit">Edit mode</button><br />';
    }

    print <<"EndOfQuestionPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="post" enctype="application/x-www-form-urlencoded">
<input type="hidden" name="user" value="$parameters{'user'}">
<input type="hidden" name="session" value="$parameters{'session'}">
$session{'groupPath'}
<table border=1 cellpadding=5 $widthTerm>
<tr><td>$item{'question'}</td></tr>
<tr><td><button name="action" value="showAnswer" type="submit">Show answer</button></td></tr>
</table>
Interval for this item: $interval<br />
Session: $sessionDuration<br />
$editButton
<a target="_new" href="mnemo?user=$parameters{'user'}&report">Show a report for $parameters{'user'}.</a>
</form>
</body>
</html>
EndOfQuestionPage
}

sub userWidthTerm() {
    my ($term) = ('width="100%"');

    if (0 != $user{'width'}) {
        $term = "width=\"$user{'width'}\"";
    }

    return $term;
}

sub prettyInterval() {
    my ($d) = @_;

    if ($d > (2 * $YEAR)) {
        return int($d / $YEAR) . ' years';
    } elsif ($d > (2 * $MONTH)) {
        return int($d / $MONTH) . ' months';
    } elsif ($d > (2 * $WEEK)) {
        return int($d / $WEEK) . ' weeks';
    } elsif ($d > (2 * $DAY)) {
        return int($d / $DAY) . ' days';
    } elsif ($d > (2 * $HOUR)) {
        return int($d / $HOUR) . ' hours';
    } elsif ($d > 120) {
        return int($d / 60) . ' minutes';
    } else {
        return "$d seconds";
    }
}

sub twoDigit() {
    my ($n) = @_;
    return substr('00' . $n, -2);
}

sub timeToStr() {
    my ($t) = @_;

    if (0 == $t) {
        return 'new';
    }

    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t);
    $sec = &twoDigit($sec);
    $min = &twoDigit($min);
    $hour = &twoDigit($hour);
    $mday = &twoDigit($mday);
    $mon = &twoDigit($mon + 1);
    $year += 1900;

    return "$dayOfWeek[$wday] $year-$mon-$mday\@$hour:$min:$sec";
}

sub answerPage() {
    my (@k);
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("answerPage: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }

    my ($sessionDuration) = &prettyInterval(time() - $parameters{'session'});
    my ($interval) = &prettyInterval($item{'interval'});
    my ($widthTerm) = &userWidthTerm;

    my ($editButton) = '';
    if (0 != $user{'showEdit'}) {
        $editButton = '<button name="action" value="edit" type="submit">Edit mode</button><br />';
    }

    print <<"EndOfAnswerPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="post" enctype="application/x-www-form-urlencoded">
<input type="hidden" name="user" value="$parameters{'user'}">
<input type="hidden" name="session" value="$parameters{'session'}">
$session{'groupPath'}
<table border=1 cellpadding=5 $widthTerm>
<tr><td>$item{'question'}</td></tr>
<tr><td>$item{'answer'}</td></tr>
</table>
<button type="submit" name="response" value="0">Huh?</button>
<button type="submit" name="response" value="1">No</button>
<button type="submit" name="response" value="2">Slow</button>
<button type="submit" name="response" value="3">Yes!</button><br />
Interval for this item: $interval<br />
Session: $sessionDuration<br />
$editButton
<a target="_new" href="mnemo?user=$parameters{'user'}&report">Show a report for $parameters{'user'}.</a>
</form>
</body>
</html>
EndOfAnswerPage
}

sub editPage() {
    my ($msg) = @_;
    my (@k);
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("editPage: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }

    my ($itemIdx) = &findStringInList($session{'itemUuid'}, @groupUuids) + 1;
    my ($itemCount) = $#groupUuids + 1;
    my ($intervalStr) = &prettyInterval($item{'interval'});
    my ($makeNewButton) = '<button type="submit" name="action" value="makeNew">Make new</button>';
    my ($makeDueButton) = '<button type="submit" name="action" value="makeDueNow">Make due now</button>';
    my ($dueTimeStr) = &timeToStr($item{'dueTime'});
    if (0 == $item{'dueTime'}) {
        $makeNewButton = '';
    } else {
        my ($dueIn) = $item{'dueTime'} - time;
        if ($dueIn <= 0) {
            $dueTimeStr .= ' (due now)';
            $makeDueButton = '';
        } else {
            $dueTimeStr .= (' (due in ' . &prettyInterval($dueIn) . ')');
        }
    }

    print <<"EndOfEditPage";

HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="post" enctype="application/x-www-form-urlencoded">
<input type="hidden" name="user" value="$parameters{'user'}">
<input type="hidden" name="session" value="$parameters{'session'}">
<input type="hidden" name="itemUuid" value="$item{'uuid'}">
<nobr>Group: '$session{'groupPath'}', item #$itemIdx of $itemCount $msg</nobr>
<table border="0" cellpadding="0"><tr><td>
<table border="1" cellpadding="5">
<tr><th>Question</th><td>$item{'question'}<br /><textarea name="question" rows="$qnaFieldRows" cols="$qnaFieldCols">$item{'question'}</textarea></td></tr>
<tr><th>Answer</th><td>$item{'answer'}<br /><textarea name="answer" rows="$qnaFieldRows" cols="$qnaFieldCols">$item{'answer'}</textarea></td></tr>
<tr><th>Interval</th><td>$intervalStr <button type="submit" name="action" value="setIntervalMinute">1 minute</button> <button type="submit" name="action" value="setIntervalHour">1 hour</button> <button type="submit" name="action" value="setIntervalDay">1 day</button></td></tr>
<tr><th>Due Time</th><td>$dueTimeStr $makeDueButton $makeNewButton</td></tr>
<tr><th>QID</th><td><tt>$item{'uuid'}</tt></td></tr>
</table>
<table border="0" cellpadding="0" width="100%">
<tr>
<td>
<button align="right" type="submit" name="action" value="save">Save</button>
</td>
<td align="center">
<nobr>
<button type="submit" name="action" value="flip">Flip</button>
<button type="submit" name="action" value="duplicate">Duplicate</button>
<button type="submit" name="action" value="delete">Delete</button>
<button type="submit" name="action" value="add">Add new item</button>
</nobr>
</td>
<td align="right">
<button align="right" type="submit" name="action" value="quit">Quit editing</button>
</td>
</tr>
</table>
<table border="0" cellpadding="0" width="100%">
<tr>
<td width="33%"><button type="submit" name="action" value="prevGroup">|&lt;&lt;-- Previous group</button></td>
<td width="33%" align="center">
<nobr>
<button type="submit" name="action" value="prevItem">&lt;-- Previous item</button>
<button type="submit" name="action" value="nextItem">Next item --&gt;</button>
</nobr>
</td>
<td width="33%" align="right"><button type="submit" name="action" value="nextGroup">Next group --&gt;&gt;|</button></td>
</tr>
</table>
</table>
<!-- <button type="submit" name="action" value="gotoItem">Go to item #:</button><input type="text" name="itemIdx"> -->
<!-- <button type="submit" name="action" value="gotoGroup">Go to group:</button><input type="text" name="groupPath" size="$maxGroupPathFieldLength"> -->
<nobr>
<button type="submit" name="action" value="moveGroup">Rename this group:</button><input type="text" name="moveGroupPath" value="$session{'groupPath'}" size="$maxGroupPathFieldLength">
</nobr>
<br />
<nobr>
<button type="submit" name="action" value="addGroup">Add new group:</button>
<input type="text" name="addGroupPath" size="$maxGroupPathFieldLength">
</nobr>
<br />
<button type="submit" name="action" value="deleteGroup">Delete this group</button>
<br />
<a target="_new" href="mnemo?user=$parameters{'user'}&report">Show a report for $parameters{'user'}.</a>
<br />
<nobr>
Download:
<a href="mnemo?user=$parameters{'user'}&session=$parameters{'session'}&action=downloadGroup">(this group)</a>
<a href="mnemo?user=$parameters{'user'}&session=$parameters{'session'}&action=downloadAll">(all groups)</a>
</nobr>
</form>
</body>
</html>
EndOfEditPage
}

sub saveItem() {
    my (@k);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("saveItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("saveItem: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }
    $item{'question'} = $parameters{'question'};
    $item{'answer'} = $parameters{'answer'};

    # Group file record separators are newlines.  Can't have those.
    $item{'question'} =~ s/\r?\n/<br \/>/mg; # HTML'ize newlines
    $item{'answer'} =~ s/\r?\n/<br \/>/mg; # HTML'ize newlines

    # Group file field separators are backslashes.  Can't have those.
    $item{'question'} =~ s/\\/&92;/g; # HTML'ize backslashes
    $item{'answer'} =~ s/\\/&92;/g; # HTML'ize backslashes

    $group{$session{'itemUuid'}} = {%item};
    &writeGroupFile;

    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    &writeSessionFile;
    $parameters{'session'} = $session{'sessionID'};
}

sub setInterval() {
    my ($seconds) = @_;

    my (@k);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("saveItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("saveItem: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }
    $item{'interval'} = $seconds;

    $group{$session{'itemUuid'}} = {%item};
    &writeGroupFile;

    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    &writeSessionFile;
    $parameters{'session'} = $session{'sessionID'};

    &editPage('(interval set)');
}

sub makeNew() {
    my (@k);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("saveItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("saveItem: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }
    $item{'interval'} = $defaultInterval;
    $item{'dueTime'} = '0';

    $group{$session{'itemUuid'}} = {%item};
    &writeGroupFile;

    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    &writeSessionFile;
    $parameters{'session'} = $session{'sessionID'};

    &editPage('(made new)');
}

sub makeDueNow() {
    my (@k);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("saveItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("saveItem: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }
    $item{'dueTime'} = time;

    $group{$session{'itemUuid'}} = {%item};
    &writeGroupFile;

    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    &writeSessionFile;
    $parameters{'session'} = $session{'sessionID'};

    &editPage('(made due now)');
}

sub gotoPrevNextItem() {
    my ($choice) = @_;

    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("gotoPrevNextItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readGroupFile;

    my ($idx) = &findStringInList($session{'itemUuid'}, @groupUuids);

    if ($idx < 0) {
        &errorPage("gotoPrevNextItem: idx=$idx Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }

    if ($choice eq 'prev') {
        if ($idx > 0) {
            $idx--; # previous item
            # else just stay on the first one
        }
    } else {
        if ($idx < $#groupUuids) {
            $idx++; # next item
            # else just stay on the last one
        }
    }

    $session{'itemUuid'} = $groupUuids[$idx];

    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %{$group{$session{'itemUuid'}}};

    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};
}

sub gotoPrevNextGroup() {
    my ($choice) = @_;

    my (@groupPaths) = &getAllGroupPaths;
    my ($idx) = &findStringInList($session{'groupPath'}, @groupPaths);

    if ($choice eq 'prev') {
        if ($idx > 0) {
            $idx--; # previous item
            # else just stay on the first one
        }
    } else {
        if ($idx < $#groupPaths) {
            $idx++; # next item
            # else just stay on the last one
        }
    }

    $session{'groupPath'} = $groupPaths[$idx];
    &readGroupFile;
    $session{'itemUuid'} = $groupUuids[0];
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %{$group{$session{'itemUuid'}}};

    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};
}

sub deleteGroup() {
    my (@groupPaths) = &getAllGroupPaths;
    my ($groupToDelete) = $session{'groupPath'};
    my ($idx) = &findStringInList($groupToDelete, @groupPaths);

    if ($idx < 0) {
        &errorPage("deleteGroup: Can't delete unfound group, '$session{'groupPath'}'.");
        exit(1);
    }
    if ($#groupPaths < 1) {
        &editPage("(Can't delete the only group.)");
        return;
    }

    unlink("$opsDir/data/$parameters{'user'}/$groupPaths[$idx].mnemo");
    &purgeEmptyFolders("$opsDir/data/$parameters{'user'}");
    @groupPaths = &getAllGroupPaths;

    if ($idx > $#groupPaths) {
        $idx--;
    }

    $session{'groupPath'} = $groupPaths[$idx];
    &readGroupFile;
    $session{'itemUuid'} = $groupUuids[0];
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %{$group{$session{'itemUuid'}}};

    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};

    &editPage("(Group '$groupToDelete' deleted.)");
}

sub isValidPath() {
    my ($path) = @_;

    if ($path =~ /^\w/) {
        $path =~ s/\w|-|\.|\/|\ //mg;
        if (length($path) == 0) {
            return 1;
        }
    }

    return 0;
}

sub createNewGroupFile() {
    my ($path) = @_;
    if (! &isValidPath($path)) {
        return 0;
    }
    my (@components) = split(/\//, $path);
    my ($file) = pop(@components) . '.mnemo';
    my ($partPath) = "$opsDir/data/$parameters{'user'}";
    while ($#components >= 0) {
        $partPath .= ('/' . shift(@components));
        if (! (-d $partPath)) {
            if (! mkdir($partPath)) {
                return 0;
            }
        }
    }
    open(NEWGROUP, ">$partPath/$file") || return 0;
    print NEWGROUP &uuidgen . "\\?\\!\n";
    close(NEWGROUP);
    return 1;
}

sub addGroup() {
    my (@groupPaths) = &getAllGroupPaths;
    my ($groupToAdd) = $parameters{'addGroupPath'};
    my ($message) = '';
    my ($idx) = &findStringInList($groupToAdd, @groupPaths);

    if (! &isValidPath($groupToAdd)) {
        $message = "('$groupToAdd' is not a valid path)";
    } elsif ($idx >= 0) {
        $session{'groupPath'} = $groupToAdd;
        $message = '(exists)';
    } else {
        if (! &createNewGroupFile($groupToAdd)) {
            $message = "(could not create '$groupToAdd')";
        } else {
            $session{'groupPath'} = $groupToAdd;
            $message = '(added)';
        }
    }

    &readGroupFile;
    $session{'itemUuid'} = $groupUuids[0];
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %{$group{$session{'itemUuid'}}};

    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};

    &editPage($message);
}

sub purgeEmptyFolders() {
    my ($path) = @_;

    if (! (-d $path)) {
        return;
    }
    if (! opendir($dh, "$path")) {
        return; # fail silently
    }
    my (@names) = grep(/^[^\.]/, readdir($dh));
    closedir($dh);

    if ($#names < 0) {
        rmdir($path);
    } else {
        foreach my $n (@names) {
            &purgeEmptyFolders("$path/$n");
        }
    }
}

sub downloadGroups() {
    my (@groupPaths) = @_;
    my ($fileName);
    if ($#groupPaths == 0) {
        $fileName = $groupPaths[0] . '.mnemo';
    } else {
        $fileName = $parameters{'user'} . '.mnemo';
    }
    print "HTTP/1.0 200 OK\n" .
          "Content-type: application/octet-stream; charset=utf-8\n" .
          "Content-disposition: attachment; filename=$fileName\n\n";
    my ($path);
    foreach $path (@groupPaths) {
        print "# $path\n";
        print join("\n", &readLinesFromFile("$opsDir/data/$parameters{'user'}/$path.mnemo"));
        print "\n\n";
    }
}

sub moveGroupFile() {
    my ($fromPath, $toPath) = @_;
    my ($line);
    if (! &isValidPath($toPath)) {
        return 0;
    }
    $fromPath = "$opsDir/data/$parameters{'user'}/$fromPath.mnemo";
    open(FROMPATH, "<$fromPath") || return 0;

    &createNewGroupFile($toPath) || return 0;
    $toPath = "$opsDir/data/$parameters{'user'}/$toPath.mnemo";
    open(TOPATH, ">$toPath") || return 0;
    while ($line = <FROMPATH>) {
        print TOPATH $line;
    }
    close(FROMPATH);
    close(TOPATH);
    unlink ("$fromPath");
    &purgeEmptyFolders("$opsDir/data/$parameters{'user'}");
    return 1;
}

sub moveGroup() {
    my ($newGroupPath) = $parameters{'moveGroupPath'};
    my ($oldGroupPath) = $session{'groupPath'};
    my ($message) = '';

    my (@groupPaths) = &getAllGroupPaths;
    my ($idx) = &findStringInList($oldGroupPath, @groupPaths);
    if ($idx < 0) {
        &errorPage("moveGroup: Group '$oldGroupPath' does not exist.");
        exit(1);
    }

    $idx = &findStringInList($newGroupPath, @groupPaths);

    if (! &isValidPath($newGroupPath)) {
        $message = "('$newGroupPath' is not a valid path)";
    } elsif ($idx >= 0) {
        $session{'groupPath'} = $newGroupPath;
        $message = '(exists)';
    } else {
        if (! &moveGroupFile($oldGroupPath, $newGroupPath)) {
            $message = "(could not move to '$newGroupPath')";
        } else {
            $session{'groupPath'} = $newGroupPath;
            $message = '(moved)';
        }
    }

    &readGroupFile;
    $session{'itemUuid'} = $groupUuids[0];
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %{$group{$session{'itemUuid'}}};

    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};

    &editPage($message);
}

sub flipItem() {
    my (@k);
    my ($tmp);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("flipItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("flipItem: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }
    $tmp = $item{'question'};
    $item{'question'} = $item{'answer'};
    $item{'answer'} = $tmp;

    $group{$item{'uuid'}} = {%item};
    &writeGroupFile;

    $session{'itemUuid'} = $item{'uuid'};
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};

    &editPage('(flipped)');
}

sub duplicateItem() {
    my (@k);
    my (%newItem);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("flipItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("flipItem: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }
    $newItem{'uuid'} = &uuidgen;
    $newItem{'question'} = $item{'question'};
    $newItem{'answer'} = $item{'answer'};
    $newItem{'dueTime'} = $item{'dueTime'};
    $newItem{'interval'} = $item{'interval'};

    my (@newGroupUuids) = ();
    while ($#groupUuids >= 0) {
        push(@newGroupUuids, shift(@groupUuids));
        if ($newGroupUuids[$#newGroupUuids] eq $item{'uuid'}) {
            last;
        }
    }
    push(@newGroupUuids, $newItem{'uuid'});
    while ($#groupUuids >= 0) {
        push(@newGroupUuids, shift(@groupUuids));
    }

    $group{$newItem{'uuid'}} = {%newItem};
    @groupUuids = @newGroupUuids;
    &writeGroupFile;

    $session{'itemUuid'} = $newItem{'uuid'};
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %newItem;
    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};

    &editPage('(duplicated)');
}

# Delete the current item and point the edit interface at the next
# item if there is one, or the last item if there isn't.
# If there are no items left, add one!
sub deleteItem() {
    my (@k);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("deleteItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readGroupFile;
    %item = %{$group{$session{'itemUuid'}}};
    @k = keys(%item);
    if ($#k < 0) {
        &errorPage("deleteItem: Group='$session{'groupPath'}' Item='$session{'itemUuid'}' NOT FOUND.");
        return;
    }

    my (@newGroupUuids) = ();
    my ($nextItemUuid) = ();
    while ($#groupUuids >= 0) {
        push(@newGroupUuids, shift(@groupUuids));
        if ($newGroupUuids[$#newGroupUuids] eq $item{'uuid'}) {
            last;
        }
    }
    if ($newGroupUuids[$#newGroupUuids] eq $item{'uuid'}) {
        pop(@newGroupUuids);
        if ($#groupUuids >= 0) {
            $nextItemUuid = $groupUuids[0];
        } elsif ($#newGroupUuids >= 0) {
            $nextItemUuid = $newGroupUuids[$#newGroupUuids];
        }
    }
    while ($#groupUuids >= 0) {
        push(@newGroupUuids, shift(@groupUuids));
    }

    @groupUuids = @newGroupUuids;
    &writeGroupFile;

    if (length($nextItemUuid) == 0) {
        &addItem;
        return;
    }

    %item = %{$group{$nextItemUuid}};

    $session{'itemUuid'} = $item{'uuid'};
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};
}

# Create a new blank item and append it to the group.
sub addItem() {
    my (%newItem);
    if ($session{'itemUuid'} ne $parameters{'itemUuid'}) {
        &errorPage("addItem: UUID MISMATCH: editing '$session{'itemUuid'}', saving '$parameters{'itemUuid'}'");
        return;
    }
    &readGroupFile;
    $newItem{'uuid'} = &uuidgen;
    $newItem{'question'} = 'Edit this question.';
    $newItem{'answer'} = 'Edit this answer.';
    $newItem{'dueTime'} = 0;
    $newItem{'interval'} = $defaultInterval;

    push(@groupUuids, $newItem{'uuid'});
    $group{$newItem{'uuid'}} = {%newItem};
    &writeGroupFile;

    $session{'itemUuid'} = $newItem{'uuid'};
    # refresh so the session doesn't expire
    $session{'sessionID'} = time;
    $parameters{'session'} = $session{'sessionID'};
    &writeSessionFile;

    %item = %newItem;
    $parameters{'itemUuid'} = $item{'uuid'};
    $parameters{'question'} = $item{'question'};
    $parameters{'answer'} = $item{'answer'};
    $parameters{'dueTime'} = $item{'dueTime'};
    $parameters{'interval'} = $item{'interval'};
}

sub userSessionDuration() {
    if (0 == $user{'sessionDuration'}) {
        return $defaultSessionDuration;
    } elsif ($minimumSessionDuration > $user{'sessionDuration'}) {
        return $minimumSessionDuration;
    } else {
        return $user{'sessionDuration'};
    }
}

# This gets all lines EXCEPT those which have '#' as the first char.
sub readLinesFromFile() {
    my ($path) = @_;

    open(INFILE, "<$path");
    my (@lines) = <INFILE>;
    close(INFILE);
    chomp(@lines);

    return(grep(/(^$)|(^[^\#])/, @lines));
}

sub writeLinesToFile() {
    my ($path, @lines) = @_;

    open(OUTFILE, ">$path");
    print OUTFILE join("\n", @lines) . "\n";
    close(OUTFILE);
}

sub readUserFile() {
    ($user{'password'},
     $user{'sessionDuration'},
     $user{'width'},
     $user{'showEdit'}
    ) = &readLinesFromFile("$opsDir/users/$parameters{'user'}");
}

sub writeUserFile() {
    &writeLinesToFile("$opsDir/users/$parameters{'user'}",
                      '# User file line fields are:',
                      '#     password',
                      '#     sessionDuration (seconds, zero invokes default)',
                      '#     width during quiz mode (pixels)',
                      '#     show edit button (0=="NO")',
                      '#',
                      $user{'password'},
                      $user{'sessionDuration'},
                      $user{'width'},
                      $user{'showEdit'}
                     );
}

sub readSessionFile() {
    %session = ();
    ($session{'sessionID'},
     $session{'groupPath'},
     $session{'itemUuid'},
     $session{'showPage'},
     $session{'response_0'},
     $session{'response_1'},
     $session{'response_2'},
     $session{'response_3'}
    ) = &readLinesFromFile("$opsDir/sessions/$parameters{'user'}");
}

sub writeSessionFile() {
    &writeLinesToFile("$opsDir/sessions/$parameters{'user'}",
                      '# Session file line fields are:',
                      '#     sessionID (session init timestamp)',
                      '#     groupPath',
                      '#     itemUuid',
                      '#     showPage (question, answer, edit)',
                      '#     number of 0 responses',
                      '#     number of 1 responses',
                      '#     number of 2 responses',
                      '#     number of 3 responses',
                      '#',
                      $session{'sessionID'},
                      $session{'groupPath'},
                      $session{'itemUuid'},
                      $session{'showPage'},
                      $session{'response_0'},
                      $session{'response_1'},
                      $session{'response_2'},
                      $session{'response_3'}
                     );
}

sub newSession() {
    $parameters{'session'} = time;
    &reinitSession;
}

sub reinitSession() {
    %session = (
        'sessionID' => $parameters{'session'},
        'groupPath' => '',
        'itemUuid' => '',
        'showPage' => 'question',
        'response_0' => 0,
        'response_1' => 0,
        'response_2' => 0,
        'response_3' => 0
    );
}

sub reportPage() {
    my (@users) = ();

    if ( (length($parameters{'user'}) > 0) &&
         (-d "$opsDir/data/$parameters{'user'}") ) {
        (@users) = ($parameters{'user'});
    }

    if ($#users < 0) {
        my ($dh);
        if (! opendir($dh, "$opsDir/data")) {
            &errorPage("reportPage: Couldn't open data dir.");
            return;
        }
        (@users) = grep(/^[^\.]/, readdir($dh));
        closedir($dh);
    }

    print <<'EndOfReportPage';
HTTP/1.0 200 ok
Content-Type: text/plain

EndOfReportPage
    my ($d, $p, $u, $i, $t, $tt);
    my ($done, $due, $new, $dueTomorrow);
    my ($t_done, $t_due, $t_new, $t_dueTomorrow);
    $t = time;
    $tt = $t + (24 * 3600); # Time Tomorrow
    foreach $u (sort(@users)) {
        $parameters{'user'} = $u;
        &readSessionFile;
        print "'$u'" .
              ' ' . &timeToStr($session{'sessionID'}) .
              " ($session{'response_0'}," .
              "$session{'response_1'}," .
              "$session{'response_2'}," .
              "$session{'response_3'})" .
              ":\n";

        ($t_done, $t_due, $t_new, $t_dueTomorrow) = (0, 0, 0, 0);
        $d = "$opsDir/data/$u/";
        foreach $p (`find "$d" -type f -name '*.mnemo' | sort`) {
            chomp($p);
            $p = substr(substr($p, length($d)), 0, -6);
            $session{'groupPath'} = $p;
            if ($#users == 0) {
                print "    '$p': ";
            }
            &readGroupFile;
            ($done, $due, $new, $dueTomorrow) = (0, 0, 0, 0);
            foreach $i (values(%group)) {
                if (0 != $$i{'dueTime'}) {
                    if ($$i{'dueTime'} > $t) {
                        $done++;
                    } else {
                        $due++;
                    }
                    if ($$i{'dueTime'} < $tt) {
                        $dueTomorrow++
                    }
                } else {
                    $new++;
                }
            }
            $t_done += $done;
            $t_due += $due;
            $t_new += $new;
            $t_dueTomorrow += $dueTomorrow;
            if ($#users == 0) {
                print "$new new, $due due, $done done ($dueTomorrow due tomorrow).\n";
            }
        }
        print '    TOTALS: ' .
              "$t_new new, $t_due due, $t_done done ($t_dueTomorrow due tomorrow).\n";
    }
}

sub passwordPage() {
    &readUserFile;

    if ($parameters{'password'} ne $user{'password'}) {
        &loginPage('Invalid.');
        return;
    }

    # write a new session file for this user.
    &newSession;
    &writeSessionFile;

    print <<"EndOfPasswordPage";
HTTP/1.1 200 ok
Refresh: 0; url=mnemo?user=$parameters{'user'}&session=$parameters{'session'}
Content-Type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
Logging in... <br />
<a href="mnemo?user=$parameters{'user'}&session=$parameters{'session'}">Click here</a> if your browser doesn't go automatically.
</body>
</html>
EndOfPasswordPage
}

sub loginPage() {
    my ($msg) = @_;
    print <<"EndOfLoginPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<head><title>Mnemo</title></head>
<body bgcolor="#ffffff">
<form name="mnemo" action="mnemo" method="post" enctype="application/x-www-form-urlencoded">
$msg<br />
user <input type="text" name="user" value="$parameters{'user'}" /> <br />
password <input type="password" name="password" /> <br />
<input type="submit" value="Log in" />
<button name="report" value="1" type="submit">Generate report</button>
</form>
</body>
</html>
EndOfLoginPage
}

sub finishedPage() {
    my ($total) = (
        $session{'response_0'} +
        $session{'response_1'} +
        $session{'response_2'} +
        $session{'response_3'});
    my (@percents) = (0, 0, 0, 0);
    if ($total != 0) {
        (@percents) = ();
        foreach my $r ( $session{'response_0'},
                        $session{'response_1'},
                        $session{'response_2'},
                        $session{'response_3'} ) {
            push(@percents, int((100.0 * $r) / $total));
        }
    }

    print <<"EndOfFinishedPage";
HTTP/1.0 200 OK
Content-type: text/html; charset=utf-8

<html>
<body bgcolor="#ffffff">
This session is finished.
<table border="1" cellpadding="5">
<tr><th>Huh?</th><td align="right">$session{'response_0'}</td><td align="right">$percents[0]%</td></tr>
<tr><th>No</th><td align="right">$session{'response_1'}</td><td align="right">$percents[1]%</td></tr>
<tr><th>Slow</th><td align="right">$session{'response_2'}</td><td align="right">$percents[2]%</td></tr>
<tr><th>Yes!</th><td align="right">$session{'response_3'}</td><td align="right">$percents[3]%</td></tr>
</table>
<p>
<a href="mnemo?user=$parameters{'user'}">Click here to start a new session.</a>
</body>
</html>
EndOfFinishedPage
}

sub errorPage() {
    my ($message) = @_;
    &debugPage('ERROR: ' . $message);
}

sub debugPage() {
    my ($message) = @_;

    print "HTTP/1.0 200 OK\nContent-type: text/plain; charset=utf-8\n\n";

    print "$message\n\n";

    print "parameters:\n";
    foreach my $k (sort(keys(%parameters))) {
        print "    '$k': '$parameters{$k}'\n";
    }

    print "session:\n";
    foreach my $k (sort(keys(%session))) {
        print "    '$k': '$session{$k}'\n";
    }

    print "groupUuids:\n";
    foreach my $k (@groupUuids) {
        print "    '$k'\n";
    }

    print "group:\n";
    foreach my $k (sort(keys(%group))) {
        print "    '$k':\n";
        foreach my $i (sort(keys(%{$group{$k}}))) {
            print "        '$i' => '${$group{$k}}{$i}'\n";
        }
    }

    print "item:\n";
    foreach my $k (sort(keys(%item))) {
        print "    '$k': '$item{$k}'\n";
    }

    my ($pwd) = `pwd`;
    chomp($pwd);

    $arguments = join(',', @ARGV);

    print <<"EndOfDebugPage";

My uid: $<
My gid: $(
My euid: $>
My egid: $)
My arguments: $arguments

PWD: $pwd

HTTPi CGI env-vars:

EndOfDebugPage

    foreach (sort keys %ENV) {
        print "$_=$ENV{$_}\n"
            if (/^QUERY_/ || /^CONTENT_/ || /^REMOTE_/ || /^REQUEST_/ ||
                /^SCRIPT_/ || /^SERVER_/ || /^HTTP_/);
    }
}

sub parseCgiParameters() {
    my ($queryString) = ($ENV{'QUERY_STRING'});
    my ($parm, $name, $val);

    %parameters = ();

    if ( (length($queryString) == 0) &&
         ($ENV{'REQUEST_METHOD'} =~ /^post$/i) &&
         ($ENV{'CONTENT_TYPE'} =~ /^application\/x-www-form-urlencoded$/) &&
         (0 < $ENV{'CONTENT_LENGTH'}) ) {
        read(STDIN, $queryString, $ENV{'CONTENT_LENGTH'});
    }

    foreach my $parm (split(/\&/, $queryString)) {
        ($name, $val) = ($parm =~ /^([^=]+)=?(.*)$/);
        $parameters{$name} = &uriDecode($val);
    }
}

sub uriDecode() {
    my ($encoded) = @_;

    $encoded =~ s/\+/ /g; # plus becomes space

    my (@parts) = split(/(\%..)/, $encoded);
    my ($decoded) = '';
    foreach my $part (@parts) {
        if ($part =~ /^\%[0123456789abcdef]{2}$/i) {
            $decoded .= (chr(hex(substr($part, 1))));
        } else {
            $decoded .= $part;
        }
    }

    #return decode('UTF-8', $decoded);
    return $decoded;
}

sub uuidgen() {
    my ($uuid) = `uuidgen`;
    chomp($uuid);
    return($uuid);
}

sub findStringInList() {
    my ($expr, @list) = @_;
    my ($idx) = -1; # this is the not-found value
    my ($pos);

    for ($pos = 0; $pos <= $#list; $pos++) {
        if ($list[$pos] eq $expr) {
            $idx = $pos;
            last;
        }
    }

    return $idx;
}

